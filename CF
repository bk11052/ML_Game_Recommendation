# ==============================================================================
# 모델명: 협업 필터링 (CF) 단독 모델
# ==============================================================================
# 코드 설명: Matrix Factorization (행렬 분해) 기법을 사용하여
#               유저-아이템 상호작용 데이터(평점) 패턴만을 학습하고 추천합니다.
#               콘텐츠(게임 제목) 정보는 사용하지 않습니다.

# 테스트 환경:
#   - 아이템 수: 50개 (극도로 희소한 데이터 환경)
#   - 테스트 유저 ID: 76561199200471638 (취향: Half-Life 시리즈)

# 주요 전략:
#   - "유사한 취향을 가진 다른 유저들이 좋아한 게임"을 예측하여 추천합니다.

# 성능 결과 (테스트 유저):
#   - 1위: ID: 100 (제목 없음)
#   - 2위: Portal
#   - 유저의 명확한 취향인 'Half-Life 2'는 순위권에 들지 못했습니다.

# 성능 평가:
#   - **저조.** 50개라는 제한된 아이템 수 때문에 CF가 개인의 취향 패턴을
#     정확히 학습하지 못하고, 데이터 노이즈(ID: 100)나 일반적 인기(Portal)에
#     휘둘리는 결과를 보여줍니다. 추천의 신뢰성이 낮습니다.
# ==============================================================================


import pandas as pd
import numpy as np
from scipy.sparse import csr_matrix
import random

# ==============================================================================
# 1. 데이터 로드 및 전처리 (review.csv 사용)
# ==============================================================================

print("1. 데이터 로드 및 전처리 시작...")

# 1.1. 파일 로드
try:
    df_reviews = pd.read_csv('review.csv')
    df_games = pd.read_csv('games.csv')
    print("   -> 파일 로드 완료: review.csv, games.csv")
except FileNotFoundError as e:
    print(f"오류: 파일을 찾을 수 없습니다. 경로를 확인해주세요. ({e})")
    exit()

# 1.2. 평점 데이터 변환 및 필터링
MIN_USER_INTERACTIONS = 1 
df_reviews['rating'] = df_reviews['is_positive'].apply(lambda x: 1 if x == 'Positive' else 0)
ratings_df = df_reviews[['author_id', 'app_id', 'rating']].copy()
user_counts = ratings_df['author_id'].value_counts()
ratings_df_final = ratings_df[ratings_df['author_id'].isin(user_counts[user_counts >= MIN_USER_INTERACTIONS].index)].copy()

user_to_index = {uid: i for i, uid in enumerate(ratings_df_final['author_id'].unique())}
game_to_index = {gid: i for i, gid in enumerate(ratings_df_final['app_id'].unique())}
index_to_game = {i: gid for gid, i in game_to_index.items()} 
ratings_df_final['u_idx'] = ratings_df_final['author_id'].map(user_to_index)
ratings_df_final['i_idx'] = ratings_df_final['app_id'].map(game_to_index)

n_users = len(user_to_index)
n_items = len(game_to_index)
R = csr_matrix((ratings_df_final['rating'].values, (ratings_df_final['u_idx'].values, ratings_df_final['i_idx'].values)),
               shape=(n_users, n_items))
print("1. 데이터 전처리 완료.")


# ==============================================================================
# 2. CF 모델: Matrix Factorization (훈련)
# ==============================================================================

class MatrixFactorization:
    def __init__(self, R, K, lr, reg, epochs):
        self.R = R
        self.n_users, self.n_items = R.shape
        self.K = K    
        self.lr = lr  
        self.reg = reg 
        self.epochs = epochs
        self.P = np.random.normal(scale=1./self.K, size=(self.n_users, self.K))
        self.Q = np.random.normal(scale=1./self.K, size=(self.n_items, self.K))
        
    def fit(self):
        rows, cols = self.R.nonzero()
        ratings = self.R.data 
        for epoch in range(self.epochs):
            for u, i, r in zip(rows, cols, ratings):
                r_hat = np.dot(self.P[u, :], self.Q[i, :])
                e = r - r_hat 
                self.P[u, :] += self.lr * (e * self.Q[i, :] - self.reg * self.P[u, :])
                self.Q[i, :] += self.lr * (e * self.P[u, :] - self.reg * self.Q[i, :])
        print("2. MF 모델 훈련 완료.")

    def predict_all(self, u_idx):
        return np.dot(self.P[u_idx, :], self.Q.T)

K_factors = 20
mf_model = MatrixFactorization(R, K=K_factors, lr=0.01, reg=0.01, epochs=30)
mf_model.fit()


# ==============================================================================
# 3. CF 추천 함수 정의
# ==============================================================================

game_title_map = df_games[df_games['app_id'].isin(ratings_df_final['app_id'].unique())].set_index('app_id')['title']

def get_cf_recommendation(user_id, n=10):
    if user_id not in user_to_index:
        return None, [f"오류: 사용자 ID {user_id}는 훈련 데이터에 없습니다."]
    
    u_idx = user_to_index[user_id]
    predicted_ratings_all = mf_model.predict_all(u_idx)
    cf_scores = pd.Series(predicted_ratings_all, index=range(n_items))

    rated_indices = ratings_df_final[ratings_df_final['author_id'] == user_id]['i_idx'].unique()
    cf_scores = cf_scores[~cf_scores.index.isin(rated_indices)]
    
    top_indices = cf_scores.sort_values(ascending=False).head(n)
    
    recommendation_list = []
    for i_idx, score in top_indices.items():
        gid = index_to_game[i_idx]
        recommendation_list.append({
            'title': game_title_map.get(gid, f"ID: {gid} (제목 없음)"),
            'app_id': gid,
            'predicted_score': score,
        })
    return mf_model.P[u_idx, :], recommendation_list


# ==============================================================================
# 4. 최종 테스트 및 결과 출력 (CF 단독)
# ==============================================================================

print("\n3. 협업 필터링(CF) 단독 추천 결과 테스트...")

# 최소 2개 이상 평점을 남긴 유저를 랜덤으로 선택하여 테스트
valid_users = ratings_df_final[ratings_df_final['author_id'].isin(user_counts[user_counts >= 2].index)]['author_id'].unique()
if len(valid_users) == 0: valid_users = ratings_df_final['author_id'].unique() 

test_user_id = valid_users[random.randint(0, len(valid_users) - 1)]
N_REC = 5 

# CF 추천 실행
user_p_cf, cf_recommendations = get_cf_recommendation(test_user_id, n=N_REC)

# 사용자가 실제로 긍정 평가한 게임 목록
rated_games_df = ratings_df_final[(ratings_df_final['author_id'] == test_user_id) & (ratings_df_final['rating'] == 1)]
rated_titles = df_games[df_games['app_id'].isin(rated_games_df['app_id'])]['title'].tolist()

print("\n" + "="*80)
print("**협업 필터링(CF) 단독 추천 결과**")
print("="*80)

if user_p_cf is not None:
    print(f"**테스트 사용자 ID**: {test_user_id}")
    print(f"**사용자가 긍정 평가한 게임 (취향)**: {', '.join(rated_titles)}")
    print("-" * 40)
    
    print(f"**추천 게임 목록 (상위 {N_REC}개)**:")
    
    # 순수한 문자열 포맷팅으로 표 출력 (tabulate 미사용)
    
    # 1. 헤더 정의 및 길이 계산
    header = ["순위", "제목", "CF Score"]
    # 제목 길이의 최대치를 40자로 제한하고, CF Score 길이를 10으로 고정하여 포맷팅
    col_widths = [len(header[0]), 40, 10] 

    # 2. 데이터 길이 측정 및 최대 길이 조정 (제목 필드만)
    for rec in cf_recommendations:
        title_len = len(rec['title'])
        if title_len > col_widths[1]:
            # 너무 긴 제목은 37자로 자르고 '...' 추가
            rec['title'] = rec['title'][:37] + '...'
            title_len = len(rec['title'])
        # 실제 출력될 제목의 길이에 맞게 열 너비 조정 (최대 40)
        col_widths[1] = max(col_widths[1], title_len)
    
    # 3. 포맷 문자열 생성
    # 예: | {:<4} | {:<40} | {:>10} |
    format_str = f"| {{:<{col_widths[0]}}} | {{:<{col_widths[1]}}} | {{:>{col_widths[2]}}} |"
    
    # 4. 헤더 출력
    print(format_str.format(header[0], header[1], header[2]))
    print("|" + "-" * (col_widths[0] + 2) + "|" + "-" * (col_widths[1] + 2) + "|" + "-" * (col_widths[2] + 2) + "|")

    # 5. 데이터 출력
    for i, rec in enumerate(cf_recommendations, 1):
        print(format_str.format(
            i,
            rec['title'],
            f"{rec['predicted_score']:.4f}"
        ))

    print("\n**분석:** 이 결과는 50개 아이템 내에서 유저들 간의 미묘한 패턴만을 찾으려는 시도입니다.")
else:
    print(cf_recommendations[0])
